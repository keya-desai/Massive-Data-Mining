# ** CS550 Massive Data Mining - Homework-3 	**
# ** Q1) Modularity  							**

import numpy as np

def modularity(A, x):

	n = len(A)
	# degree
	k = np.sum(A, axis = 0)
	m = np.sum(k)/2

	Q = 0
	for i in range(n):
		for j in range(n):
			Q += (A[i][j] - (k[i]*k[j])/(2*m) ) * x[i] * x[j]
	Q = Q/(4*m)

	return Q

if __name__ == "__main__":

	# part - a
	A = np.array([[0, 1, 1, 1, 0, 0, 1, 0],
			[1, 0, 1, 1, 0, 0, 0, 0],
			[1, 1, 0, 1, 0, 0, 0, 0],
			[1, 1, 1, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 0],
			[0, 0, 0, 0, 1, 0, 1, 0],
			[1, 0, 0, 0, 1, 1, 0, 1],
			[0, 0, 0, 0, 0, 0, 1, 0]])

	x = [1, 1, 1, 1, -1, -1, -1, -1]
	print(modularity(A, x))

	# part - b
	A = np.array([[0, 1, 1, 1, 0, 0, 1, 0],
				[1, 0, 1, 1, 0, 0, 0, 0],
				[1, 1, 0, 1, 0, 0, 0, 0],
				[1, 1, 1, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 1, 1, 1],
				[0, 0, 0, 0, 1, 0, 1, 0],
				[1, 0, 0, 0, 1, 1, 0, 1],
				[0, 0, 0, 0, 1, 0, 1, 0]])

	x = [1, 1, 1, 1, -1, -1, -1, -1]
	print(modularity(A, x))

	# part - c
	A = np.array([[0, 1, 1, 1, 0, 1, 1, 0],
			[1, 0, 1, 1, 0, 0, 0, 0],
			[1, 1, 0, 1, 0, 0, 0, 0],
			[1, 1, 1, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 0],
			[1, 0, 0, 0, 1, 0, 1, 0],
			[1, 0, 0, 0, 1, 1, 0, 1],
			[0, 0, 0, 0, 0, 0, 1, 0]])

	x = [1, 1, 1, 1, -1, -1, -1, -1]
	print(modularity(A, x))

